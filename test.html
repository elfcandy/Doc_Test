
/class BuildIP :: public IPCircuit {
class BuildIP
{
//	public:
//		BuildIP();
//		virtual ~BuildIP();
	public:
		unsigned Process ();
	private:
		std::map <int, std::string>  intToStr;
		std::map <int, int>  		 intToInt;

		std::map <std::string, int>  mapStr;
		std::map <std::string, int>::iterator itStr;
//		std::ostringstream oss;
	private:
		unsigned InitMap();
		unsigned SearchMap();
};

unsigned BuildIP :: Process()
{
	InitMap();
	SearchMap();
}

unsigned BuildIP :: InitMap()
{
	//mapStr.insert( StrToInt_Pair ("1", 111) );
	//mapStr.insert( ("aaa", 222) );
	//mapStr.insert( StrToInt_Pair ("bbb", 333) );
	mapStr["1"] = 111;
	mapStr["aa"] = 222;
	mapStr["bb"] = 333;
	mapStr["cc"] = 444;
	return 1;
}

unsigned BuildIP :: SearchMap()
{
	//std::map <std::string, int>::iterator itStr;
	itStr = mapStr.find("1");
	std::cout << "The element of map: a key is: " << itStr->first << "; a value is: "<< itStr->second << "." << '\n';
	itStr = mapStr.find("aa");
	std::cout << "The element of map: a key is: " << itStr->first << "; a value is: "<< itStr->second << "." << '\n';
	itStr = mapStr.find("bb");
	std::cout << "The element of map: a key is: " << itStr->first << "; a value is: "<< itStr->second << "." << '\n';
	itStr = mapStr.find("cc");
	std::cout << "The element of map: a key is: " << itStr->first << "; a value is: "<< itStr->second << "." << '\n';

	mapStr.erase("aa");
	itStr = mapStr.find("aa");
	if ( itStr == mapStr.end() ) {
		std::cout << "This str \"aa\" doesn't exist." << '\n';
	} else {
		std::cout << "The element of map: a key is: " << itStr->first << "; a value is: "<< itStr->second << "." << '\n';
	}
	itStr = mapStr.find("bb");
	std::cout << "The element of map: a key is: " << itStr->first << "; a value is: "<< itStr->second << "." << '\n';

	mapStr.clear();
	if (mapStr.find("cc") == mapStr.end()) {
		std::cout << "This str \"cc\" doesn't exist." << '\n';
	}
	return 1;
}


int main()
{
	BuildIP Build_IP;
	Build_IP.Process();
    return 0;
}


============================================================================================================
#include <map>
#include <iostream>

IP_BEGIN_NAMESPACE

class BuildIP : public IPCircuit {
	public:
		ROMBist ();
		virtual ~ROMBist ();
	public:
		unsigned Process ();
	private:
		std::map <int, std::string>   intToStr;
		std::map <std::string, int>   strToInt;
		std::map <int, int>   intToInt;
		std::ostringstream oss;



}

IP_END_NAMESPACE


#if 0
//#include <functional>
//#include <ext/hash_map>
#include <hash_map>
#include <iostream>

using namespace __gnu_cxx;

namespace __gnu_cxx
{
	template<> struct hash<std::string>
	{
		size_t operator()(const std::string & s) const
		{
			return __stl_hash_string(s.c_str());
		}
	};
}

/*
namespace __gnu_cxx
{
	template<> struct hash< std::string >
	{
		size_t operator()( const std::string& x ) const
		{
			return hash< const char* >()( x.c_str() );
		}
   	 };
}
*/


int main()
{
/*
	typedef pair <int, int> Int_Pair;
    //std::hash <int> hasher;
	hash_map<int, int> hasher;
	hasher.insert(pair<int, int>(1, 23));
	hasher.insert ( Int_Pair ( 2, 20 ) );
	hasher.insert ( Int_Pair ( 3, 30 ) );

	hash_map<int, int>::iterator it;
	it = hasher.find(1);
    //cout << "The element of hash_map hm1 with a key of 1 is:" << it -> second << "." << endl;
	std::cout << "The element of hash_map hasher with a key of 1 is: " << it -> first << "." << '\n';
	std::cout << "The element of hash_map hasher with a value of 1 is: " << it -> second << "." << '\n';
	it = hasher.find(3);
	std::cout << "The element of hash_map hasher with a key of 3 is: " << it -> first << "." << '\n';
	std::cout << "The element of hash_map hasher with a value of 3 is: " << it -> second << "." << '\n';

	hasher.erase(it);
	std::cout << "The element of hash_map hasher with a key of 1 is: " << it -> first << "." << '\n';
	std::cout << "The element of hash_map hasher with a value of 1 is: " << it -> second << "." << '\n';
    //cout << hasher(1) << endl;
    //cout << hasher(2) << endl;
    //cout << hasher(3) << endl;
    //cout << hasher(4) << endl;
*/

	hash_map<std::string, int> hashstring;
	hashstring.insert(pair<std::string, int>("1", 111));
	hashstring.insert(pair<std::string, int>("aaa", 222));
	hashstring.insert(pair<std::string, int>("bbb", 333));
	hash_map<std::string, int>::iterator itstring;

	itstring = hashstring.find("1");
	std::cout << "The element of hash_map hasher with a key of 3 is: " << itstring -> first << "." << '\n';
	std::cout << "The element of hash_map hasher with a value of 3 is: " << itstring -> second << "." << '\n';
	hashstring.erase(itstring);
	std::cout << "The element of hash_map hasher with a key of 3 is: " << itstring -> first << "." << '\n';
	std::cout << "The element of hash_map hasher with a value of 3 is: " << itstring -> second << "." << '\n';
	itstring = hashstring.find("bbb");
	std::cout << "The element of hash_map hasher with a key of 3 is: " << itstring -> first << "." << '\n';
	std::cout << "The element of hash_map hasher with a value of 3 is: " << itstring -> second << "." << '\n';

    return 0;
}
#endif


#if 0
//#include <functional>
#include <ext/hash_map>
#include <hash_map>
#include <iostream>

using namespace __gnu_cxx;


int main()
{
	typedef pair <int, int> Int_Pair;
    //std::hash <int> hasher;
	hash_map<int , int> hasher;
	hasher.insert(pair<int, int>(1, 23));
	hasher.insert ( Int_Pair ( 2, 20 ) );
	hasher.insert ( Int_Pair ( 3, 30 ) );

	hash_map<int, int>::iterator it;
	it = hasher.find(1);
    //cout << "The element of hash_map hm1 with a key of 1 is:" << it -> second << "." << endl;
	std::cout << "The element of hash_map hasher with a key of 1 is: " << it -> first << "." << '\n';
	std::cout << "The element of hash_map hasher with a value of 1 is: " << it -> second << "." << '\n';
	it = hasher.find(3);
    //cout << "The element of hash_map hm1 with a key of 1 is:" << it -> second << "." << endl;
	std::cout << "The element of hash_map hasher with a key of 3 is: " << it -> first << "." << '\n';
	std::cout << "The element of hash_map hasher with a value of 3 is: " << it -> second << "." << '\n';
	hasher.erase(it);
	std::cout << "The element of hash_map hasher with a key of 1 is: " << it -> first << "." << '\n';
	std::cout << "The element of hash_map hasher with a value of 1 is: " << it -> second << "." << '\n';
    //cout << hasher(1) << endl;
    //cout << hasher(2) << endl;
    //cout << hasher(3) << endl;
    //cout << hasher(4) << endl;

    return 0;
}

#endif


#if 0
#include <stdio.h>
#include <iostream>
#include <string>
#include <ext/hash_map>
using namespace __gnu_cxx;
 
int main(int argc, char** argv)
{
	hash_map<int , int> hm;
	hm.insert(pair<int, int>(1, 23));
	hash_map<int, int>::iterator it;
	it = hm.find(1);
	//std::cout << "nts1 and nts2: " << (ptr_hash(nts1)==ptr_hash(nts2)) << '\n';
	//std::cout << "The element of hash_map hm1 with a key of 2 is: " << it << "." << '\n';
	cout << "The element of hash_map hm1 with a key of 2 is: " << it -> second << "." << endl;
	hm.erase(it);
	return 0;
}
#endif

#if 0
// hash_map_find.cpp
// compile with: /EHsc
#define _DEFINE_DEPRECATED_HASH_CLASSES 0
#include <hash_map>
#include <iostream>

#include <functional>

//using namespace std;

using namespace std;
//using namespace stdext;

int main( )
{
	hash_map <int, int> hm1;
	hash_map <int, int> :: const_iterator hm1_AcIter, hm1_RcIter;
	typedef pair <int, int> Int_Pair;

	hm1.insert ( Int_Pair ( 1, 10 ) );
	hm1.insert ( Int_Pair ( 2, 20 ) );
	hm1.insert ( Int_Pair ( 3, 30 ) );

	hm1_RcIter = hm1.find( 2 );
	cout << "The element of hash_map hm1 with a key of 2 is: " << hm1_RcIter -> second << "." << endl;

	// If no match is found for the key, end( ) is returned
	hm1_RcIter = hm1.find( 4 );

	if ( hm1_RcIter == hm1.end( ) )
		cout << "The hash_map hm1 doesn't have an element " << "with a key of 4." << endl;
	else
		cout << "The element of hash_map hm1 with a key of 4 is: " << hm1_RcIter -> second << "." << endl;

	// The element at a specific location in the hash_map can be found 
	// using a dereferenced iterator addressing the location
	hm1_AcIter = hm1.end( );
	hm1_AcIter--;
	hm1_RcIter = hm1.find( hm1_AcIter -> first );
	cout << "The element of hm1 with a key matching " << "that of the last element is: " << hm1_RcIter -> second << "." << endl;
}
#endif



#if 0
#include <iostream>
#include <functional>
#include <string>

int main ()
{
	char nts1[] = "Test";
	char nts2[] = "Test";
	std::string str1 (nts1);
	std::string str2 (nts2);

	std::hash<char*> ptr_hash;
	std::hash<std::string> str_hash;

	std::cout << "same hashes:\n" << std::boolalpha;
	std::cout << "nts1 and nts2: " << (ptr_hash(nts1)==ptr_hash(nts2)) << '\n';
	std::cout << "str1 and str2: " << (str_hash(str1)==str_hash(str2)) << '\n';

	return 0;
}
#endif


#if 0
#include <iostream>
#include <functional>

using namespace std;

int main()
{
    std::hash <int> hasher;
    cout << hasher(2) << endl;
    cout << hasher(3) << endl;
    cout << hasher(4) << endl;

    return 0;
}
#endif


#if 0
#include <iostream>
#include <functional>
#include <string>
using namespace std;
 
//int _tmain(int argc, char* argv[])
int _tmain(int argc, _TCHAR* argv[])
{
	char nts1[] = "Test";
	char nts2[] = "Test";
	string str1 (nts1);
	string str2 (nts2);
						 
	hash<char*> ptr_hash;
	hash<string> str_hash;
								 
	cout<<"hash value of nts1: "<<ptr_hash(nts1)<<endl;
	cout<<"hash value of nts2: "<<ptr_hash(nts2)<<endl;
	cout<<"hash value of str1: "<<str_hash(str1)<<endl;
	cout<<"hash value of str2: "<<str_hash(str2)<<endl;
				 
	cout << "same hashes:\n" << boolalpha;
	cout << "nts1 and nts2: " << (ptr_hash(nts1)==ptr_hash(nts2)) << '\n';
	cout << "str1 and str2: " << (str_hash(str1)==str_hash(str2)) << '\n';
	 
	return 0;
}

#endif






===============================================================================
https://blog.csdn.net/qq632544991p/article/details/51713903
https://blog.csdn.net/wesleyluo/article/details/7046865

https://blog.csdn.net/liu798675179/article/details/52189700
https://blog.csdn.net/q_l_s/article/details/52416583

g++ a.cpp -std=c++11

=============================================================================

<!DOCTYPE html>
        <head>
            <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
            <title>GCC 使用汇总</title>
            <link rel="stylesheet" type="text/css" href="test.css"/>
            <script type="text/script" src="text.js" charset="utf-8"></script>
        </head>
        <body>
         ## Welcome to GCC </script>

         gcc user guide </script>

#if 0
#include <stdio.h>
#include <unistd.h>
#include <stdint.h>

//#include <stdlib.h>
//#include <string.h>

typedef void (*myown_call)(void);

extern myown_call _myown_start;
extern myown_call _myown_end;

#define _init __attribute__((unused, section(".myown")))
#define func_init(func) myown_call _fn_##func _init = func

static void mspec1(void)
{
        write(1, "aha!\n", 5);
}

static void mspec2(void)
{
        write(1, "aloha!\n", 7);
}

static void mspec3(void)
{
        write(1, "hello!\n", 7);
}


func_init(mspec1);
func_init(mspec2);
func_init(mspec3);


/* exactly like below:
static myown_call mc1  __attribute__((unused, section(".myown"))) = mspec1;
static myown_call mc2  __attribute__((unused, section(".myown"))) = mspec2;
static myown_call mc3  __attribute__((unused, section(".myown"))) = mspec3;
*/


void do_initcalls(void)
{
        myown_call *call_ptr = &_myown_start;
        do {
                fprintf (stderr, "call_ptr: %p\n", call_ptr);
                (*call_ptr)();
                ++call_ptr;
        } while (call_ptr < &_myown_end);

}

int main(void)
{
        do_initcalls();
        return 0;
}
#endif



#if 0
#include <stdarg.h>
#include <stdio.h>

int sum(int, ...);

int main()
{
   printf("Sum of 15 and 56 = %d",  sum(2, 15, 56) );
   return 0;
}

int sum(int num_args, ...)
{
   int val = 0;
   va_list ap;
   int i;

   va_start(ap, num_args);
   for(i = 0; i < num_args; i++) 
   {
      val += va_arg(ap, int);
   }
   va_end(ap);
 
   return val;
}
#endif




#include <stdio.h>
#include <stdlib.h>
#include <string.h>


char *stall_pipe_sharing_type[7] = {
		"SHARING_FOR_PAUSE",
		"SHARING_FOR_DM_CACHE",
		"SHARING_FOR_DM_NOCACHE",
		"SHARING_FOR_DM_WBUF_FULL",
		"SHARING_FOR_DM_TO_ITCM",
		"SHARING_FOR_PM_CACHE",
		"SHARING_FOR_PM_NOCACHE"
	};

typedef struct {
	int f1;
	struct b_1 *b;
}a_1;

struct {
	int f2;
	a_1 *a;
}b_1;


typedef enum {
	A_1 = 0,
	A_2,
	A_3 = 0,
	C1_123
}enum_A;

typedef enum {
	B_1 = 0,
	B_2,
	B_3,
	C2_123
}enum_B;


void main(void)
{
	a_1 *value_1; 

	char format[100] = {A_1};
	unsigned int unit_len;

	unit_len = sizeof(long);
//	sprintf(format, "long = %d", unit_len);
	fprintf(stderr, "long = %d\n", unit_len);
	unit_len = sizeof(unsigned int);
	fprintf(stderr, "unsigned int = %d\n", unit_len);
	unit_len = sizeof(unsigned long);
	fprintf(stderr, "unsigned long = %d\n", unit_len);
	unit_len = sizeof(unsigned long long);
	fprintf(stderr, "unsigned long long = %d\n", unit_len);

	//char *ptr;
	//ptr = &stall_pipe_sharing_type[0][0]; 
	//ptr += 1;
	value_1 = (a_1 *)calloc(1, sizeof(a_1));
	value_1->f1 += B_3;

	//sprintf(format,"%d",(unsigned int)value_1->b);
}






         gcc使用总结: </script>

         1、使用gcc进行编译的说明：</script>
  
        </body>
    </html>


